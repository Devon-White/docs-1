import OriginalNavbar from "@theme-original/Navbar";
import styles from "./styles.module.css";
import React, { useState, useEffect } from "react";
import { useHistory, useLocation } from "@docusaurus/router";
import Link from "@docusaurus/Link";
import { FontAwesomeIcon } from "@fortawesome/react-fontawesome";
import { faChevronDown } from "@fortawesome/free-solid-svg-icons";
import secondaryNavOptions from "/secondaryNavbar.js";

const sidebars = require("/sidebars.js");

export default function NavbarWrapper(props) {
  const history = useHistory();
  const location = useLocation();
  const [selectedOption, setSelectedOption] = useState("build");
  const [isModalOpen, setModalOpen] = useState(false);
  const [activeLink, setActiveLink] = useState("");

  useEffect(() => {
    const defaultNavbar = document.querySelector(`.${styles.defaultNavbar}`);
    const secondaryNavbar = document.querySelector(
      `.${styles.secondaryNavbar}`
    );
    const placeholder = document.createElement("div");

    placeholder.classList.add(styles.secondaryNavbarPlaceholder);

    if (secondaryNavbar) {
      secondaryNavbar.insertAdjacentElement("afterend", placeholder);
    }

    const handleScroll = () => {
      if (window.scrollY > defaultNavbar.offsetHeight) {
        secondaryNavbar.classList.add(styles.fixOnTop);
        placeholder.style.display = "block";
      } else {
        secondaryNavbar.classList.remove(styles.fixOnTop);
        placeholder.style.display = "none";
      }
    };

    window.addEventListener("scroll", handleScroll);
    return () => window.removeEventListener("scroll", handleScroll);
  }, []);

  useEffect(() => {
    let currentPath = location.pathname;
    if (currentPath.startsWith("/")) {
      currentPath = currentPath.slice(1);
    }
    // If currentPath is empty (i.e. homepage), set to default
    if (!currentPath) {
      const firstOptionKey = Object.keys(secondaryNavOptions)[0];
      setSelectedOption(firstOptionKey);
      setActiveLink(secondaryNavOptions[firstOptionKey].links[0].sidebar);
      return;
    }

    for (const [key, value] of Object.entries(secondaryNavOptions)) {
      if (
        value.links.some(
          (link) =>
            currentPath.includes(link.link.slice(1)) && link.link !== "/"
        )
      ) {
        setSelectedOption(key);
        break;
      }
    }

    function findPathInItems(items, currentPath) {
      for (const item of items) {
        // If the item is a string, then it represents a doc id.
        if (typeof item === "string") {
          if (item.includes(currentPath)) {
            return true;
          }
        }
        // If the item is a document type object.
        else if (item.type === "doc") {
          if (item.id.includes(currentPath)) {
            return true;
          }
        }
        // If the item is a autogenerated type object.
        else if (item.type === "autogenerated") {
          if (currentPath.includes(item.dirName)) {
            return true;
          }
        }
        // If the item is a category type object.
        else if (item.type === "category") {
          // Optionally check if the category’s link is a doc that matches.
          if (
            item.link &&
            item.link.type === "doc" &&
            item.link.id.includes(currentPath)
          ) {
            return true;
          }
          // Recursively check in its child items.
          if (
            Array.isArray(item.items) &&
            findPathInItems(item.items, currentPath)
          ) {
            return true;
          }
        }
      }
      return false;
    }

    // Loop over each sidebar defined in the sidebars configuration.
    for (const [sidebarName, items] of Object.entries(sidebars)) {
      const matchFound = findPathInItems(items, currentPath);
      if (matchFound) {
        setActiveLink(sidebarName);
        break;
      } else {
        setActiveLink(null);
      }
    }
  }, [location.pathname]); // Re-run the effect whenever the pathname changes

  const handleOptionSelect = (option) => {
    setSelectedOption(option);
    setModalOpen(false);

    // Navigate to the first item in the selected category
    const firstItem = secondaryNavOptions[option]?.links[0];
    if (firstItem) {
      history.push(firstItem.link);
    }
  };

  return (
    <>
      {/* Default Docusaurus Navbar */}
      <div className={`${styles.defaultNavbar}`}>
        <OriginalNavbar {...props} />
      </div>

      {/* Secondary Navbar */}
      <div className={`${styles.secondaryNavbar}`}>
        <button
          className={styles.modalButton}
          onClick={() => setModalOpen(true)}
        >
          <FontAwesomeIcon
            icon={secondaryNavOptions[selectedOption]?.icon}
            className={styles.optionIcon}
          />
          {secondaryNavOptions[selectedOption]?.title}
          <FontAwesomeIcon icon={faChevronDown} className={styles.arrowIcon} />
        </button>

        <nav className={styles.secondaryNavLinks}>
          {secondaryNavOptions[selectedOption]?.links.map((item, index) => {
            const isActive = activeLink && item.sidebar == activeLink;
            return (
              <Link
                key={index}
                to={item.link}
                className={
                  isActive
                    ? `${styles.navLink} ${styles.activeNavLink}`
                    : styles.navLink
                }
              >
                {item.label}
              </Link>
            );
          })}
        </nav>
      </div>

      {/* Modal for Category Selection */}
      {isModalOpen && (
        <div
          className={styles.modalOverlay}
          onClick={() => setModalOpen(false)}
        >
          <div
            className={styles.modalContent}
            onClick={(e) => e.stopPropagation()}
          >
            {/* Close Button (X) in Upper Right */}
            <button
              className={styles.closeIcon}
              onClick={() => setModalOpen(false)}
            >
              ✕
            </button>

            <div className={styles.modalTitle}>
              <strong>Go to documentation:</strong>
            </div>
            <div className={styles.modalOptionsContainer}>
              {Object.entries(secondaryNavOptions).map(([key, value]) => (
                <div
                  key={key}
                  className={styles.modalOption}
                  onClick={() => handleOptionSelect(key)}
                >
                  <FontAwesomeIcon
                    icon={value.icon}
                    className={styles.modalIcon}
                  />
                  <div className={styles.modalText}>
                    <strong>{value.title}</strong>
                    <p>{value.description}</p>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}
    </>
  );
}
